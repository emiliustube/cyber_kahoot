# Cyber Kahoot - Документация функций (Русский)

## Содержание
- [Server.py - класс my_server](#serverpy---класс-my_server)
- [KahootClient.py - класс KahootClient](#kahootclientpy---класс-kahootclient)
- [Player.py - класс Player](#playerpy---класс-player)

---

## Server.py - класс my_server

### `__init__(self, port)`
**Описание:** Конструктор, который инициализирует сервер Kahoot.
- Создает серверный сокет и привязывает его к указанному порту
- Инициализирует пустые списки для игроков и клиентов
- Настраивает переменные состояния игры (game_started, waiting_for_answers, current_correct_answer)

**Параметры:**
- `port` - номер порта, на котором сервер будет прослушивать подключения

---

### `run_server(self)`
**Описание:** Основной цикл сервера, который обрабатывает все подключения клиентов и сообщения.
- Использует select.select() для эффективного мониторинга нескольких сокетов без блокировки
- Проверяет новые подключения и входящие сообщения каждые 0.1 секунды
- Направляет новые подключения в handle_new_connection()
- Направляет сообщения клиентов в handle_request()

**Возвращает:** None (работает бесконечно до остановки)

---

### `handle_new_connection(self)`
**Описание:** Обрабатывает новые подключения клиентов к серверу.
- Принимает новые соединения клиентских сокетов
- Добавляет клиентский сокет в список клиентов
- Отправляет сообщение "NAME_REQUEST" для запроса имени игрока
- Выводит подтверждение подключения в консоль сервера

**Возвращает:** None

---

### `find_player_by_socket(self, client_socket)`
**Описание:** Ищет объект игрока по его сокет-соединению.
- Перебирает список игроков для поиска соответствующего сокета
- Используется для идентификации игрока, отправившего сообщение

**Параметры:**
- `client_socket` - соединение сокета для поиска

**Возвращает:** объект Player, если найден, None, если не найден

---

### `handle_request(self, client_socket)`
**Описание:** Обрабатывает входящие сообщения от клиентов.
- Получает и декодирует сообщения от клиентских сокетов
- Обрабатывает несколько сообщений, разделенных переносами строк
- Направляет сообщения по типу: START_GAME, QUESTION, STOP_GAME или числовые ответы
- Вызывает register_player() для новых игроков
- Обрабатывает отключения клиентов

**Параметры:**
- `client_socket` - сокет, отправивший сообщение

**Возвращает:** None

---

### `register_player(self, client_socket, name)`
**Описание:** Регистрирует нового игрока в игре.
- Создает новый объект Player с указанным именем
- Назначает роль ADMIN первому игроку, роль PLAYER остальным
- Отправляет подтверждение роли клиенту
- Рассылает системное сообщение о присоединении нового игрока

**Параметры:**
- `client_socket` - соединение сокета нового игрока
- `name` - имя, выбранное игроком

**Возвращает:** None

---

### `start_game(self)`
**Описание:** Запускает игровую сессию.
- Устанавливает флаг game_started в True
- Рассылает сообщение "GAME_STARTED" всем подключенным клиентам
- Подсчитывает и отображает количество игроков (не администраторов)
- Выводит подтверждение в консоль сервера

**Возвращает:** None

---

### `send_question(self, message)`
**Описание:** Отправляет вопрос всем игрокам (кроме администратора).
- Разбирает формат сообщения вопроса: QUESTION:текст|вар1|вар2|вар3|вар4|правильный_ответ
- Проверяет наличие игроков в игре
- Сохраняет правильный ответ внутри
- Отправляет вопрос без правильного ответа всем игрокам (не администраторам)
- Инициализирует словарь waiting_for_answers

**Параметры:**
- `message` - полная строка вопроса с форматом QUESTION:текст|варианты|правильный_ответ

**Возвращает:** None

---

### `calculate_round_results(self)`
**Описание:** Рассчитывает и распределяет результаты после того, как все игроки ответили.
- Сравнивает ответ каждого игрока с правильным ответом
- Начисляет очки игрокам, которые ответили правильно
- Отправляет индивидуальные сообщения о результатах (правильно/неправильно) каждому игроку
- Создает сводку раунда с результатами
- Сортирует игроков по очкам и рассылает таблицу лидеров
- Очищает словарь waiting_for_answers для следующего раунда

**Возвращает:** None

---

### `handle_answer(self, player, answer)`
**Описание:** Обрабатывает ответ игрока на вопрос.
- Сохраняет ответ игрока в словаре waiting_for_answers
- Отслеживает, сколько игроков ответили
- Проверяет, ответили ли все игроки
- Вызывает calculate_round_results(), когда все ответы получены

**Параметры:**
- `player` - объект Player, который отправил ответ
- `answer` - строка ответа (обычно "1", "2", "3" или "4")

**Возвращает:** None

---

### `stop_game(self)`
**Описание:** Останавливает игру и отображает финальную статистику.
- Устанавливает флаг game_started в False
- Собирает всех игроков (не администраторов)
- Сортирует игроков по очкам (от большего к меньшему)
- Создает отформатированное сообщение об окончании игры с финальными результатами
- Объявляет победителя
- Рассылает финальную статистику всем клиентам

**Возвращает:** None

---

### `broadcast(self, message)`
**Описание:** Отправляет сообщение всем подключенным клиентам.
- Перебирает все клиентские сокеты
- Кодирует и отправляет сообщение каждому клиенту
- Тихо обрабатывает ошибки отправки (пропускает неудачные отправки)

**Параметры:**
- `message` - текстовое сообщение для рассылки

**Возвращает:** None

---

### `remove_client(self, client_socket)`
**Описание:** Удаляет отключившегося клиента с сервера.
- Находит связанный объект Player
- Удаляет игрока из списка игроков
- Удаляет сокет из списка клиентов
- Закрывает соединение сокета
- Выводит сообщение об отключении в консоль сервера

**Параметры:**
- `client_socket` - соединение сокета для удаления

**Возвращает:** None

---

## KahootClient.py - класс KahootClient

### `__init__(self, ip, port)`
**Описание:** Конструктор, который инициализирует клиент Kahoot и подключается к серверу.
- Создает соединение сокета
- Подключается к серверу по указанному IP и порту
- Инициализирует переменные состояния клиента (is_admin, running, role_received)
- Выводит подтверждение подключения

**Параметры:**
- `ip` - IP-адрес сервера для подключения
- `port` - номер порта сервера для подключения

---

### `send_message(self, message)`
**Описание:** Отправляет сообщение на сервер.
- Кодирует строку сообщения в байты
- Отправляет её через клиентский сокет
- Обрабатывает ошибки с выводом сообщения об ошибке

**Параметры:**
- `message` - текстовое сообщение для отправки на сервер

**Возвращает:** None

---

### `receive_message(self)`
**Описание:** Получает сообщение от сервера.
- Получает до 1024 байт от сервера
- Декодирует байты в строку
- Возвращает None при возникновении ошибки

**Возвращает:** строку полученного сообщения или None при ошибке

---

### `listen_to_server(self)`
**Описание:** Непрерывно прослушивает сообщения от сервера (работает в потоке).
- Получает сообщения в цикле
- Обрабатывает отключения
- Направляет сообщения по типу: NAME_REQUEST, ROLE, SYSTEM, GAME_STARTED, QUESTION, RESULT, GAME_OVER
- Управляет состоянием клиента на основе сообщений сервера

**Возвращает:** None (работает до отключения клиента)

---

### `handle_question(self, message)`
**Описание:** Обрабатывает и отображает вопрос, полученный от сервера.
- Разбирает формат вопроса: QUESTION:текст|вариант1|вариант2|вариант3|вариант4
- Отображает текст вопроса
- Отображает пронумерованные варианты (1-4)
- Форматирует вывод для удобства пользователя

**Параметры:**
- `message` - сообщение с вопросом от сервера

**Возвращает:** None

---

### `admin_control(self)`
**Описание:** Интерфейс администратора для управления игрой.
- Принимает команды администратора: start, question, stop
- Отправляет команду START_GAME для начала игры
- Позволяет администратору создавать и отправлять вопросы с 4 вариантами
- Запрашивает правильный ответ после отправки вопроса
- Отправляет команду STOP_GAME для завершения игры

**Возвращает:** None

---

### `player_control(self)`
**Описание:** Интерфейс игрока для ответов на вопросы.
- Ожидает ввода пользователя
- Проверяет ответы (должны быть 1, 2, 3 или 4)
- Отправляет корректные ответы на сервер
- Игнорирует пустой ввод
- Показывает ошибку при неверном вводе

**Возвращает:** None

---

### `start(self)`
**Описание:** Запускает клиентское приложение.
- Создает и запускает демон-поток для прослушивания сервера
- Ожидает назначения роли от сервера
- Направляет в admin_control(), если пользователь - администратор
- Направляет в player_control(), если пользователь - обычный игрок
- Закрывает сокет по завершении

**Возвращает:** None

---

## Player.py - класс Player

### `__init__(self, name, points, admin, client_socket, addr)`
**Описание:** Конструктор, который создает новый объект Player.
- Сохраняет имя игрока, очки и статус администратора
- Сохраняет соединение сокета клиента и адрес

**Параметры:**
- `name` - имя игрока
- `points` - начальные очки (обычно 0)
- `admin` - логическое значение, указывающее, является ли игрок администратором
- `client_socket` - соединение сокета для этого игрока
- `addr` - сетевой адрес игрока

---

### `GetPoints(self)`
**Описание:** Возвращает текущее количество очков игрока.

**Возвращает:** целое число, представляющее очки игрока

---

### `SetPoints(self, num)`
**Описание:** Устанавливает очки игрока на определенное значение.

**Параметры:**
- `num` - новое значение очков

**Возвращает:** None

---

### `AddPoint(self)`
**Описание:** Добавляет одно очко к счету игрока.
- Используется, когда игрок отвечает на вопрос правильно

**Возвращает:** None

---

### `RemPoint(self)`
**Описание:** Убирает одно очко из счета игрока.
- Может использоваться для штрафов (в настоящее время не используется в игре)

**Возвращает:** None

---

### `GetName(self)`
**Описание:** Возвращает имя игрока.

**Возвращает:** строка с именем игрока

---

### `SetName(self, name)`
**Описание:** Изменяет имя игрока.

**Параметры:**
- `name` - новое имя для игрока

**Возвращает:** None

---

### `IsAdmin(self)`
**Описание:** Проверяет, имеет ли игрок права администратора.

**Возвращает:** логическое значение - True, если администратор, False, если обычный игрок

---

## Краткое описание структуры проекта

- **Server.py** - основное серверное приложение, управляющее игрой
- **KahootClient.py** - клиентское приложение для администратора и игроков
- **Player.py** - класс данных, представляющий игрока в игре

## Протокол сообщений

Приложение использует текстовый протокол со следующими типами сообщений:

- `NAME_REQUEST` - сервер запрашивает имя у клиента
- `ROLE:ADMIN` / `ROLE:PLAYER` - сервер назначает роль
- `START_GAME` - администратор запускает игру
- `QUESTION:текст|вар1|вар2|вар3|вар4` - вопрос с вариантами
- `RESULT:сообщение` - результат ответа (правильно/неправильно)
- `ROUND_OVER:сводка` - конец раунда с результатами
- `GAME_OVER:статистика` - игра завершена с финальной статистикой
- `SYSTEM:сообщение` - системные объявления
